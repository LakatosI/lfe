.\" Automatically generated by Pandoc 1.17.1
.\"
.TH "lfe_clj" "3" "2015\-2016" "" ""
.hy
.SH NAME
.PP
clj \- LFE Clojure interface library.
.SH SYNOPSIS
.PP
This module provides Clojure\-inpired functions and macros for use in
LFE.
.SH EXPORTS
.SS Function Composition
.PP
\f[B](compose f g)\f[]
.PP
Right to left function composition.
.PP
\f[B](compose fs x)\f[]
.PP
Compose a list of functions \f[C]fs\f[], right to left, and apply the
resulting function to \f[C]x\f[].
.PP
\f[B](compose f g x)\f[]
.PP
Equivalent to \f[C](funcall\ (compose\ f\ g)\ x)\f[].
.PP
\f[B](compose fs)\f[]
.PP
Compose a list of functions \f[C]fs\f[] from right to left.
.PP
\f[B](compose)\f[]
.PP
Equivalent to \f[C]#\[aq]identity/1\f[].
.SS Usage
.PP
The following examples assume \f[C]#\[aq]1+/1\f[] is defined:
.IP
.nf
\f[C]
>\ (defun\ 1+\ (x)\ (+\ x\ 1))
1+
\f[]
.fi
.IP
.nf
\f[C]
>\ (funcall\ (clj:compose\ #\[aq]math:sin/1\ #\[aq]math:asin/1)\ 0.5)
0.49999999999999994
>\ (funcall\ (clj:compose\ (list\ #\[aq]1+/1\ #\[aq]math:sin/1\ #\[aq]math:asin/1)\ 0.5))
1.5
\f[]
.fi
.PP
Or used in another function call:
.IP
.nf
\f[C]
>\ (lists:filter\ (compose\ #\[aq]not/1\ #\[aq]zero?/1)
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \[aq](0\ 1\ 0\ 2\ 0\ 3\ 0\ 4))
(1\ 2\ 3\ 4)
\f[]
.fi
.PP
The usage above is best when \f[C]compose\f[] will be called by
higher\-order functions like \f[C]lists:foldl/3\f[] or
\f[C]lists:filter/2\f[], etc.
However, one may also call \f[C]compose\f[] in the following manner,
best suited for direct usage:
.IP
.nf
\f[C]
>\ (compose\ #\[aq]math:sin/1\ #\[aq]math:asin/1\ 0.5)
0.49999999999999994
>\ (compose\ (list\ #\[aq]1+/1\ #\[aq]math:sin/1\ #\[aq]math:asin/1)\ 0.5)
1.5
\f[]
.fi
.SS Partial Application
.PP
\f[B](partial f args)\f[]
.PP
\f[B](partial f arg\-1)\f[]
.PP
Partially apply \f[C]f\f[] to a given argument \f[C]arg\-1\f[] or list
of \f[C]args\f[].
.SS Usage
.IP
.nf
\f[C]
>\ (set\ f\ (partial\ #\[aq]+/2\ 1))
#Fun<clj.3.121115395>
>\ (funcall\ f\ 2)
3
>\ (set\ f\ (partial\ #\[aq]+/3\ 1))
#Fun<clj.3.121115395>
>\ (funcall\ f\ \[aq](2\ 3))
6
>\ (set\ f\ (partial\ #\[aq]+/3\ \[aq](2\ 3)))
#Fun<clj.3.121115395>
>\ (funcall\ f\ 4)
9
>\ (set\ f\ (partial\ #\[aq]+/4\ \[aq](2\ 3)))
#Fun<clj.3.121115395>
>\ (funcall\ f\ \[aq](4\ 5))
14
\f[]
.fi
.SS Other Functions
.PP
\f[B](identity x)\f[]
.PP
Identity function.
.SS Threading Macros
.PP
Note: The original versions were copied from Tim Dysinger\[aq]s lfesl
repo here:
.IP
.nf
\f[C]
https://github.com/lfex/lfesl/blob/master/include/thread.lfe
\f[]
.fi
.PP
\f[B](\-> ...)\f[]
.PP
Thread first.
.PP
Example usage, demonstrating ordering:
.IP
.nf
\f[C]
>\ (set\ o\ \[aq](#(a\ 1)\ #(b\ 2)\ #(c\ 3)))
(#(a\ 1)\ #(b\ 2)\ #(c\ 3))
>\ (\->\ o
>\ \ \ \ \ (++\ \[aq](#(d\ 4)))
>\ \ \ \ \ (++\ \[aq](#(e\ 5)))
>\ \ \ \ \ (++\ \[aq](#(f\ 6))))
(#(a\ 1)\ #(b\ 2)\ #(c\ 3)\ #(d\ 4)\ #(e\ 5)\ #(f\ 6))
\f[]
.fi
.PP
Note that the use of \f[C]\->\f[] in this example results in each
successive value being \f[I]appended\f[] to the input list.
.PP
Another example showing how this works:
.IP
.nf
\f[C]
>\ (lists:sublist
>\ \ \ (lists:reverse
>\ \ \ \ \ (lists:sort
>\ \ \ \ \ \ \ (lists:merge
>\ \ \ \ \ \ \ \ \ (string:tokens
>\ \ \ \ \ \ \ \ \ \ \ (string:to_upper\ "a\ b\ c\ d\ e")
>\ \ \ \ \ \ \ \ \ \ \ "\ ")
>\ \ \ \ \ \ \ \ \ \[aq]("X"\ "F"\ "L"))))
>\ \ \ 2\ 3)
("L"\ "F"\ "E")
\f[]
.fi
.PP
Can be rewritten as this:
.IP
.nf
\f[C]
>\ (\->\ "a\ b\ c\ d\ e"
>\ \ \ \ \ (string:to_upper)
>\ \ \ \ \ (string:tokens\ "\ ")
>\ \ \ \ \ (lists:merge\ \[aq]("X"\ "F"\ "L"))
>\ \ \ \ \ (lists:sort)
>\ \ \ \ \ (lists:reverse)
>\ \ \ \ \ (lists:sublist\ 2\ 3))
("L"\ "F"\ "E")
\f[]
.fi
.PP
\f[B](\->> ...)\f[]
.PP
Thread last.
.PP
Example usage, demonstrating ordering:
.IP
.nf
\f[C]
>\ (set\ o\ \[aq](#(a\ 1)\ #(b\ 2)\ #(c\ 3)))
(#(a\ 1)\ #(b\ 2)\ #(c\ 3))
>\ (\->>\ o
>\ \ \ \ \ \ (++\ \[aq](#(d\ 4)))
>\ \ \ \ \ \ (++\ \[aq](#(e\ 5)))
>\ \ \ \ \ \ (++\ \[aq](#(f\ 6))))
(#(f\ 6)\ #(e\ 5)\ #(d\ 4)\ #(a\ 1)\ #(b\ 2)\ #(c\ 3))
\f[]
.fi
.PP
Note that the use of \f[C]\->>\f[] in this example results in each
successive value being \f[I]prepended\f[] to the input list.
.PP
Another example showing how this:
.IP
.nf
\f[C]
>\ (lists:foldl\ #\[aq]+/2\ 0
>\ \ \ (take\ 10
>\ \ \ \ \ (lists:filter
>\ \ \ \ \ \ \ (compose\ #\[aq]even?/1\ #\[aq]round/1)
>\ \ \ \ \ \ \ (lists:map
>\ \ \ \ \ \ \ \ \ (lambda\ (x)
>\ \ \ \ \ \ \ \ \ \ \ (math:pow\ x\ 2))
>\ \ \ \ \ \ \ \ \ (seq\ 42)))))
1540.0
\f[]
.fi
.PP
Can be rewritten as this:
.IP
.nf
\f[C]
>\ (\->>\ (seq\ 42)
>\ \ \ \ \ \ (lists:map\ (lambda\ (x)\ (math:pow\ x\ 2)))
>\ \ \ \ \ \ (lists:filter\ (compose\ #\[aq]even?/1\ #\[aq]round/1))
>\ \ \ \ \ \ (take\ 10)
>\ \ \ \ \ \ (lists:foldl\ #\[aq]+/2\ 0))
1540.0
\f[]
.fi
.SH AUTHORS
Tim Dysinger, Duncan McGreggor, Eric Bailey.
